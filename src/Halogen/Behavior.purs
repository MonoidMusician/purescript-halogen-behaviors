module Halogen.Behavior where

import Prelude

import CSS (CSS, black, color, fontStyle, italic)
import CSS.Common (normal)
import CSS.Text.Transform (capitalize, textTransform)
import Color.Scheme.Clrs (blue, green, purple, red)
import Control.Apply (lift2)
import Effect.Aff.Class (class MonadAff)
import Effect (Effect)
import Control.Monad.Maybe.Trans (MaybeT(..), runMaybeT)
import Control.MonadZero (guard)
import Data.Bifunctor (bimap)
import Data.Const (Const)
import Data.Foldable (for_)
import Data.Int (even, round)
import Data.Maybe (Maybe(..))
import Data.Set (size)
import Data.Tuple (Tuple(..))
import Data.Variant (Variant)
import FRP.Behavior (Behavior)
import FRP.Behavior.Keyboard (key)
import FRP.Event.Keyboard (getKeyboard)
import FRP.Behavior.Mouse (buttons)
import FRP.Event.Mouse (getMouse)
import FRP.Behavior.Time (seconds)
import Halogen (RefLabel(..))
import Halogen as H
import Halogen.Aff (awaitBody, runHalogenAff)
import Halogen.Behavior.ElementBehaviors (class ElementBehaviors, allAttrs, mkBehaviors, update)
import Halogen.Behavior.Internal (class Nothings, class NothingsRL, AroundState(..), initialize, mapIProp, renderCSS, snapshot, uninitializedAS)
import Halogen.Behavior.Internal.MultiAttrBehavior (class MultiAttrBehavior, class MultiAttrBehaviorRL, handle, shouldUpdate, subscribe, toProps)
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.HTML.Properties as HP
import Halogen.Query.EventSource as ES
import Halogen.VDom.Driver (runUI)
import Type.Row (RProxy(..))
import Type.RowList (class ListToRow)
import Prim.Row (class Union)
import Prim.RowList (class RowToList)
import Unsafe.Coerce (unsafeCoerce)
import Web.HTML.HTMLElement (toElement) as HTMLElement
import Web.HTML.HTMLInputElement as HTMLInputElement
import Data.Symbol (SProxy(..))
import Web.Event.Event (target)
import Data.Newtype (unwrap)

type State callbacks partial i =
  { value :: i
  , as :: AroundState partial
  , pushers :: Maybe (Record callbacks)
  }
initialState :: forall callbacks partial i. Nothings partial => i -> State callbacks partial i
initialState =
  { value: _
  , as: uninitializedAS
  , pushers: Nothing
  }

data Action internals partial o
  = Lift o
  | UpdateProp (Variant partial)
  | UpdateBehavior (Variant internals)

type SimpleHTML m o = H.ComponentHTML o () m

-- | A Halogen component that allows using behaviors to style and set properties
-- | on an element. Directly updates the DOM, to avoid rerenders. Uses
-- | `requestAnimationFrame` (indirectly) to sample the behaviors.
-- |
-- | Okay let's have a go at documenting this.
-- |
-- | Arguments: `behavioralParentComponent node renderWith behavior`
-- | - `node`: A regular Halogen node constructor, like `HH.div`, or
-- |   `\a _ -> HH.input a` (since `<input>` does not have children,
-- |   it will just ignore them).
-- | - `renderWith raise el i`: The renderer function
-- |    - `raise`: Raise an output value through the opaque query.
-- |    - `el`: The element constructor, a combination of `node` with some
-- |       pre-filled-in properties.
-- |    - `i :: i`: The latest input passed to the component. Viz., this
-- |      function is called only when the input changes.
-- | - `behavior`: The transformation from the element behaviors to the
-- |   property behaviors.
-- |
-- | Type variables:
-- | - `g`: The query for child(ren).
-- | - `p`: The slot type for child(ren). Requires `Ord` so Halogen can keep
-- |   track of the slots.
-- | - `m`: The monad this component runs in, must be `MonadAff`.
-- | - `i`: The input value for this component, passed to the render function.
-- | - `o`: The output of the component.
-- | - `all`: The allowed properties for the node being rendered.
-- | - `required`: The properties used by the event handlers.
-- | - `other`: The properties allowed to be set by the rendering function
-- |   on the focused element.
-- | - `behaviors`: A row of behaviors for the properties, each behavior uses
-- |   `Nothing` to indicate the property should be removed.
-- | - `partial`: Like `behaviors` but without the behaviors (used internally).
-- | - `ebehaviors`: The behaviors generated by this component, including things
-- |   like `hover` and `focus`.
-- | - `callbacks`: Used internally to update `ebehaviors` using events.
-- | - `internals`: Just the internal value used by each element behavior.
-- | - `eff`: Going to die in flames soon.
behavioralParentComponent ::
  forall slots m i o all required other behaviors partial ebehaviors callbacks internals arl prl brl.
    MonadAff m =>
    ElementBehaviors all ebehaviors callbacks internals =>
    Union required other all =>
    RowToList required arl =>
    ListToRow arl required =>
    RowToList partial prl =>
    ListToRow prl partial =>
    RowToList behaviors brl =>
    ListToRow brl behaviors =>
    NothingsRL prl partial =>
    MultiAttrBehavior required partial behaviors =>
    MultiAttrBehaviorRL arl prl brl required partial behaviors =>
  (forall w q. HH.Node all w q) ->
  (forall o'.
    (o -> o') ->
    (
      Array (HH.IProp other o) ->
      Array (HH.ComponentHTML o slots m) ->
      HH.ComponentHTML o' slots m
    ) ->
    i ->
    HH.ComponentHTML o' slots m
  ) ->
  (
    Record ebehaviors ->
    Record behaviors
  ) ->
  H.Component HH.HTML (Const Void) i o m
behavioralParentComponent node renderWith behavior =
  H.mkComponent
    { render
    , eval
    , initialState:
      { value: _
      , as: (uninitializedAS :: AroundState partial)
      , pushers: Nothing
      }
    }
  where
    label = RefLabel "behavioral-component"
    addRefProps = ([HP.ref label] <> _)
    expand1 = unsafeCoerce :: (Array (HH.IProp other o) -> Array (HH.IProp (all) o))
    expand2 = unsafeCoerce :: (Array (HH.IProp required o) -> Array (HH.IProp (all) o))
    events :: Array (HH.IProp all (Action internals partial o))
    events = mapIProp UpdateBehavior <$> allAttrs (RProxy :: RProxy ebehaviors)
    lift1 :: o -> Action internals partial o
    lift1 = Lift
    adapt :: HH.ComponentHTML o slots m -> HH.ComponentHTML (Action internals partial o) slots m
    adapt = bimap (map lift1) lift1
    lifting :: Array (HH.IProp all o) -> Array (HH.IProp all (Action internals partial o))
    lifting = map (mapIProp (lift1))

    -- Render the component. Delegates to the passed in renderer,
    -- lifts all communication from it.
    render :: State callbacks partial i -> HH.ComponentHTML (Action internals partial o) slots m
    render { value, as: (AroundState { insideState: latest }), pushers } =
      let
        props = addRefProps (toProps latest)
        renderer attrs children =
          node (events <> lifting (expand1 attrs <> expand2 props))
          (adapt <$> children)
      in renderWith lift1 renderer value

    eval ::
      H.HalogenQ (Const Void) (Action internals partial o) i ~>
      H.HalogenM (State callbacks partial i) (Action internals partial o) slots o m
    -- Initialize the component.
    eval (H.Initialize a) = a <$ do
      -- Run the finalizer, just in case ....
      eval (H.Finalize unit)
      -- Create a ref from the latest style
      as <- H.gets _.as >>= initialize >>> H.liftEffect
      -- And store it in state!
      H.modify_ (_ { as = as })
      Tuple status pushers <- H.liftEffect $ mkBehaviors (RProxy :: RProxy all)
      H.modify_ (_ { pushers = Just pushers })
      -- Start animating the behavior
      void $ H.subscribe $ ES.effectEventSource \e ->
        ES.Finalizer <$> subscribe (behavior status) (ES.emit e <<< UpdateProp)
    -- Update for a new input for the renderer.
    eval (H.Receive s a) = a <$ do
      as <- H.gets _.as >>= snapshot >>> H.liftEffect
      H.modify_ (_ { value = s, as = as })
    -- Destroy the component.
    eval (H.Finalize a) = pure a
    -- Raise a query from the HTML to this component's output.
    eval (H.Action (Lift q) a) = a <$ do
      H.raise q
    -- Secretely set the style directly on the element, update the reference.
    -- Should *not* write to state.
    eval (H.Action (UpdateProp mprop) a) = a <$ runMaybeT do
      -- Set the style directly on the DOM element
      el <- HTMLElement.toElement <$> MaybeT (H.getHTMLElementRef label)
      ref <- MaybeT $ H.gets \{as: AroundState { outsideState }} -> outsideState
      shouldupdate <- H.liftEffect $ shouldUpdate ref mprop
      guard shouldupdate
      H.liftEffect $ handle el mprop
    eval (H.Action (UpdateBehavior which) a) = a <$ runMaybeT do
      pushers <- MaybeT $ H.gets _.pushers
      H.liftEffect $ update (RProxy :: RProxy ebehaviors) (RProxy :: RProxy all) pushers which
    eval (H.Query _ f) = pure (f unit)

-- | `behavioralParentComponent` but without the parent component stuff.
behavioralComponent ::
  forall m all i o required partial behaviors ebehaviors callbacks internals other arl prl brl.
    MonadAff m =>
    MultiAttrBehavior required partial behaviors =>
    ElementBehaviors all ebehaviors callbacks internals =>
    Union required other all =>
    RowToList required arl =>
    ListToRow arl required =>
    RowToList partial prl =>
    ListToRow prl partial =>
    RowToList behaviors brl =>
    ListToRow brl behaviors =>
    NothingsRL prl partial =>
    MultiAttrBehavior required partial behaviors =>
    MultiAttrBehaviorRL arl prl brl required partial behaviors =>
  (forall w q. HH.Node all w q) ->
  (forall o'.
    (o -> o') ->
    (
      Array (HH.IProp other o) ->
      Array (SimpleHTML m o) ->
      SimpleHTML m o'
    ) ->
    i ->
    SimpleHTML m o'
  ) ->
  (
    Record ebehaviors ->
    Record behaviors
  ) ->
  H.Component HH.HTML (Const Void) i o m
behavioralComponent = behavioralParentComponent

-- | Combinator for adding CSS when a behavior returns `true`.
-- |
-- | Use like so:
-- | ```purescript
-- | hover ?> textTransform capitalize
-- | ```
cssWhen :: Behavior Boolean -> CSS -> Behavior CSS
cssWhen bb v = bb <#> \b -> when b v

infixl 4 cssWhen as ?>

-- | Combinator for picking between two (CSS) values.
-- |
-- | Use like so:
-- | ```purescript
-- | blink <#> choose color blue green
-- | ```
choose :: forall a b. (a -> b) -> a -> a -> Boolean -> b
choose f l r = if _ then f r else f l

-- | Combine two CSS behaviors into one.
-- |
-- | I like this formatting style with it:
-- | ```purescript
-- | ( hover ?> textTransform capitalize
-- | & blink <#> choose color blue green
-- | & pressed <#> choose fontStyle normal italic
-- | )
-- | ```
lifted :: Behavior CSS -> Behavior CSS -> Behavior CSS
lifted = lift2 (*>)

infixl 0 lifted as &

-- | Lift a CSS behavior
styleB :: Behavior CSS -> { style :: Behavior (Maybe String) }
styleB = { style: _ } <<< map renderCSS

main :: Effect Unit
main = do
  keyboard <- getKeyboard
  mouse <- getMouse
  let
    pressed = buttons mouse <#> size >>> (_ > 0)
    blink = seconds <#> unwrap >>> round >>> even
    spacebar = key keyboard "Space"
    b :: { hover :: Behavior Boolean } -> { "style" :: Behavior (Maybe String), "class" :: Behavior (Maybe String) }
    b { hover } =
      { "style": renderCSS <$>
        ( hover ?> textTransform capitalize
        & blink <#> choose color blue green
        & pressed <#> choose fontStyle normal italic
        )
      , "class": spacebar <#> if _ then Just "align-right" else Nothing
      }
    help = "Mouse press anywhere on the page makes this text italic!"
    component1 = (behavioralComponent HH.h1 <@> b) \_ el t ->
      el [] [ HH.text t, HH.span_ [ HH.text " my span" ] ]
    inputColor :: { focus :: Behavior Boolean, hover :: Behavior Boolean } -> { style :: Behavior (Maybe String) }
    inputColor { focus, hover } = styleB $
      (\f h -> color
        if f
        then if h then purple else blue
        else if h then red else black
      ) <$> focus <*> hover
    component2 = (behavioralComponent (\a _ -> HH.input a) <@> inputColor) \_ el v ->
      el [ HP.value v, HE.onInput Just ] []
    parent = H.mkComponent
      { render: \v ->
        HH.div_
          [ HH.slot (SProxy :: SProxy "1") unit component2 v pure
          , HH.slot (SProxy :: SProxy "2") unit component1 v absurd
          ]
      , eval: H.mkEval H.defaultEval
        { handleAction = \e -> do
            for_ (target e >>= HTMLInputElement.fromEventTarget)
              (HTMLInputElement.value >>> H.liftEffect >=> H.put)
        }
      , initialState: const help
      }
  runHalogenAff $ awaitBody >>= runUI parent unit
